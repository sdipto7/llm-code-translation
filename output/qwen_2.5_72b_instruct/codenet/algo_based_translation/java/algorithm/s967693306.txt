main:
- function signature: `public static void main(String[] args)`
- execution: 
  - creates new instance of Main class and calls solve method

solve:
- function signature: `void solve()`
- variable declarations: `int n = sc.nextInt(); int m = sc.nextInt(); Map<Integer, Integer> map = new HashMap<>();`
- loop: `for(int i = 0; i < m; i++)`
  - variable declarations: `int s = sc.nextInt(); int c = sc.nextInt();`
  - conditional: `if(map.get(s) != null && map.get(s) != c)`
    - output: `System.out.println(-1); System.exit(0);`
  - operation: `map.put(s, c);`
- loop: `for(int i = 0; i < 1000; i++)`
  - variable declarations: `String s = "" + i; boolean flag = true;`
  - conditional: `if(s.length() < n)`
    - continue
  - loop: `for(int j = 0; j < n; j++)`
    - conditional: `if((map.get(j + 1) != null && map.get(j + 1) != Character.getNumericValue(s.charAt(j))) || (map.get(j + 1) == null && Character.getNumericValue(s.charAt(j)) != 0))`
      - conditional: `if(map.get(j + 1) == null && j == 0 && Character.getNumericValue(s.charAt(j)) == 1)`
        - continue
      - operation: `flag = false; break;`
  - conditional: `if(flag && s.length() == n)`
    - output: `System.out.println(s); System.exit(0);`
- output: `System.out.println(-1);`

gcd:
- function signature: `long gcd(long a, long b)`
- conditional: `if(b == 0)`
  - return: `a`
- return: `gcd(b, a % b)`

lcm:
- function signature: `long lcm(long a, long b)`
- return: `a * b / gcd(a, b)`

inv:
- function signature: `long inv(long a)`
- return: `pow(a, MOD - 2)`

pow:
- function signature: `long pow(long a, long r)`
- variable declarations: `long sum = 1;`
- loop: `while(r > 0)`
  - conditional: `if((r & 1) == 1)`
    - operation: `sum *= a; sum %= MOD;`
  - operation: `a *= a; a %= MOD;`
  - operation: `r >>= 1;`
- return: `sum`

modFact:
- function signature: `long modFact(long n)`
- conditional: `if(n == 0)`
  - return: `1`
- return: `n * modFact(n - 1) % MOD`

fact:
- function signature: `long fact(long n)`
- conditional: `if(n == 0)`
  - return: `1`
- return: `n * fact(n - 1)`

initCOMB:
- function signature: `void initCOMB()`
- variable declarations: `fac[0] = fac[1] = 1; inv[1] = 1; finv[0] = finv[1] = 1;`
- loop: `for(int i = 2; i < SIZE; i++)`
  - operation: `fac[i] = fac[i - 1] * i % MOD;`
  - operation: `inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;`
  - operation: `finv[i] = finv[i - 1] * inv[i] % MOD;`

modComb:
- function signature: `long modComb(int n, int r)`
- conditional: `if(n < r || n < 0 || r < 0)`
  - return: `0`
- return: `fac[n] * finv[r] % MOD * finv[n - r] % MOD`

comb:
- function signature: `long comb(long n, long r)`
- variable declarations: `long num = 1;`
- loop: `for(long i = 1; i <= r; i++)`
  - operation: `num = num * (n - i + 1) / i;`
- return: `num`

isPrime:
- function signature: `boolean isPrime(long a)`
- conditional: `if(a <= 1)`
  - return: `false`
- loop: `for(int i = 2; i * i <= a; i++)`
  - conditional: `if(a % i == 0)`
    - return: `false`
- return: `true`

nextPermutation (String):
- function signature: `String nextPermutation(String s)`
- variable declarations: `ArrayList<Character> list = new ArrayList<>();`
- loop: `for(int i = 0; i < s.length(); i++)`
  - operation: `list.add(s.charAt(i));`
- variable declarations: `int pivotPos = -1; char pivot = 0;`
- loop: `for(int i = list.size() - 2; i >= 0; i--)`
  - conditional: `if(list.get(i) < list.get(i+1))`
    - operation: `pivotPos = i; pivot = list.get(i); break;`
- conditional: `if(pivotPos == -1 && pivot == 0)`
  - return: `null`
- variable declarations: `int L = pivotPos + 1; int R = list.size() - 1; int minPos = -1; char min = Character.MAX_VALUE;`
- loop: `for(int i = R; i >= L; i--)`
  - conditional: `if(pivot < list.get(i))`
    - conditional: `if(list.get(i) < min)`
      - operation: `min = list.get(i); minPos = i;`
- operation: `Collections.swap(list, pivotPos, minPos);`
- operation: `Collections.sort(list.subList(L, R + 1));`
- variable declarations: `StringBuilder sb = new StringBuilder();`
- loop: `for(int i=0; i<list.size(); i++)`
  - operation: `sb.append(list.get(i));`
- return: `sb.toString()`

nextPermutation (long[]):
- function signature: `boolean nextPermutation(long[] a)`
- loop: `for(int i = a.length - 1; i > 0; i--)`
  - conditional: `if(a[i - 1] < a[i])`
    - variable declarations: `int swapIndex = find(a[i - 1], a, i, a.length - 1);`
    - operation: `long temp = a[swapIndex]; a[swapIndex] = a[i - 1]; a[i - 1] = temp;`
    - operation: `Arrays.sort(a, i, a.length);`
    - return: `true`
- return: `false`

find:
- function signature: `int find(long dest, long[] a, int s, int e)`
- conditional: `if(s == e)`
  - return: `s`
- variable declarations: `int m = (s + e + 1) / 2;`
- conditional: `if(a[m] <= dest)`
  - return: `find(dest, a, s, m - 1)`
- return: `find(dest, a, m, e)`

elimination:
- function signature: `void elimination(int[][] a, int[] b)`
- variable declarations: `int n = a.length; double f;`
- loop: `for(int k = 0; k < n - 1; k++)`
  - loop: `for(int i = k + 1; i < n; i++)`
    - operation: `f = - a[i][k] / a[k][k];`
    - loop: `for(int j = k + 1; j < n; j++)`
      - operation: `a[i][j] += f * a[k][j];`
    - operation: `b[i] += f * b[k];`
  - loop: `for(int i = n - 1; i >= 0; i--)`
    - loop: `for(int j = i + 1; j < n; j++)`
      - operation: `b[i] -= a[i][j] * b[j];`
    - operation: `b[i] = b[i] / a[i][i];`

Pair:
- constructor: `public Pair(long i, long j)`
- method signature: `@Override public int compareTo(Pair p)`
- conditional: `if(this.b < p.b)`
  - return: `-1`
- conditional: `if(this.b > p.b)`
  - return: `1`
- return: `0`

FastScanner:
- variable declarations: `private final InputStream in = System.in; private final byte[] buffer = new byte[1024]; private int ptr = 0; private int buflen = 0;`
- method signature: `private boolean hasNextByte()`
- conditional: `if(ptr < buflen)`
  - return: `true`
- operation: `ptr = 0;`
- operation: `buflen = in.read(buffer);`
- conditional: `if(buflen <= 0)`
  - return: `false`
- return: `true`
- method signature: `private int readByte()`
- conditional: `if(hasNextByte())`
  - return: `buffer[ptr++];`
- return: `-1`
- method signature: `private static boolean isPrintableChar(int c)`
- conditional: `if(33 <= c && c <= 126)`
  - return: `true`
- return: `false`
- method signature: `public boolean hasNext()`
- loop: `while(hasNextByte() && !isPrintableChar(buffer[ptr]))`
  - operation: `ptr++;`
- return: `hasNextByte();`
- method signature: `public String next()`
- conditional: `if(!hasNext())`
  - throw: `new NoSuchElementException();`
- variable declarations: `StringBuilder sb = new StringBuilder(); int b = readByte();`
- loop: `while(isPrintableChar(b))`
  - operation: `sb.appendCodePoint(b); b = readByte();`
- return: `sb.toString();`
- method signature: `public long nextLong()`
- conditional: `if(!hasNext())`
  - throw: `new NoSuchElementException();`
- variable declarations: `long n = 0; boolean minus = false; int b = readByte();`
- conditional: `if(b == '-')`
  - operation: `minus = true; b = readByte();`
- conditional: `if(b < '0' || '9' < b)`
  - throw: `new NumberFormatException();`
- loop: `while(true)`
  - conditional: `if('0' <= b && b <= '9')`
    - operation: `n *= 10; n += b - '0';`
  - conditional: `if(b == -1 || !isPrintableChar(b))`
    - return: `minus ? -n : n;`
  - conditional: `else`
    - throw: `new NumberFormatException();`
  - operation: `b = readByte();`
- method signature: `public int nextInt()`
- variable declarations: `long nl = nextLong();`
- conditional: `if(nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)`
  - throw: `new NumberFormatException();`
- return: `(int) nl;`
- method signature: `public double nextDouble()`
- return: `Double.parseDouble(next());`
