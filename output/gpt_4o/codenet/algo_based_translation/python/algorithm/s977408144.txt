```python
# Libraries and dependencies
import sys

# Function signatures
def yn(b: bool) -> None:
    ...

def Yn(b: bool) -> None:
    ...

def YN(b: bool) -> None:
    ...

class union_find:
    def __init__(self, n: int) -> None:
        # Variables and data types
        self.n: int = n
        self.P: List[int] = [a for a in range(n)]
        self.rank: List[int] = [0] * n

    def find(self, x: int) -> int:
        # Logic flow: path compression
        if x != self.P[x]:
            self.P[x] = self.find(self.P[x])
        return self.P[x]

    def same(self, x: int, y: int) -> bool:
        return self.find(x) == self.find(y)

    def link(self, x: int, y: int) -> None:
        # Logic flow: union by rank
        if self.rank[x] < self.rank[y]:
            self.P[x] = y
        elif self.rank[y] < self.rank[x]:
            self.P[y] = x
        else:
            self.P[x] = y
            self.rank[y] += 1

    def unite(self, x: int, y: int) -> None:
        self.link(self.find(x), self.find(y))

    def size(self) -> int:
        # Logic flow: find unique components
        S: Set[int] = set()
        for a in range(self.n):
            S.add(self.find(a))
        return len(S)

def is_power(a: int, b: int) -> bool:
    now: int = b
    while now < a:
        now *= b
    return now == a

def bin_(num: int, size: int) -> List[int]:
    A: List[int] = [0] * size
    for a in range(size):
        if (num >> (size - a - 1)) & 1 == 1:
            A[a] = 1
        else:
            A[a] = 0
    return A

def get_facs(n: int, mod_: int = 0) -> List[int]:
    A: List[int] = [1] * (n + 1)
    for a in range(2, len(A)):
        A[a] = A[a - 1] * a
        if mod_ > 0:
            A[a] %= mod_
    return A

def comb(n: int, r: int, mod: int, fac: List[int]) -> int:
    if n - r < 0:
        return 0
    return (fac[n] * pow(fac[n - r], mod - 2, mod) * pow(fac[r], mod - 2, mod)) % mod

def next_comb(num: int, size: int) -> Union[bool, int]:
    x: int = num & (-num)
    y: int = num + x
    z: int = num & (~y)
    z //= x
    z = z >> 1
    num = (y | z)
    if num >= (1 << size):
        return False
    else:
        return num

def get_primes(n: int, type: str = "int") -> Union[List[bool], List[int]]:
    A: List[bool] = [True] * (n + 1)
    A[0] = False
    A[1] = False
    for a in range(2, n + 1):
        if A[a]:
            for b in range(a * 2, n + 1, a):
                A[b] = False
    if type == "bool":
        return A
    B: List[int] = []
    for a in range(n + 1):
        if A[a]:
            B.append(a)
    return B

def is_prime(num: int) -> bool:
    if num <= 2:
        return False
    i: int = 2
    while i * i <= num:
        if num % i == 0:
            return False
        i += 1
    return True

def ifelse(a: bool, b: Any, c: Any) -> Any:
    if a:
        return b
    else:
        return c

def join(A: List[Any], c: str = " ") -> str:
    n: int = len(A)
    A: List[str] = list(map(str, A))
    s: str = ""
    for a in range(n):
        s += A[a]
        if a < n - 1:
            s += c
    return s

def factorize(n: int, type_: str = "dict") -> Union[Dict[int, int], List[int], None]:
    b: int = 2
    list_: List[int] = []
    while b * b <= n:
        while n % b == 0:
            n //= b
            list_.append(b)
        b += 1
    if n > 1:
        list_.append(n)
    if type_ == "dict":
        dic: Dict[int, int] = {}
        for a in list_:
            if a in dic:
                dic[a] += 1
            else:
                dic[a] = 1
        return dic
    elif type_ == "list":
        return list_
    else:
        return None

def floor_(n: int, x: int = 1) -> int:
    return x * (n // x)

def ceil_(n: int, x: int = 1) -> int:
    return x * ((n + x - 1) // x)

def hani(x: int, min_: int, max_: int) -> int:
    ret: int = x
    if x < min_:
        ret = min_
    if x > max_:
        ret = max_
    return ret

def seifu(x: int) -> int:
    return x // abs(x)

def main() -> None:
    # Input reading, variable declaration, and data processing
    n, l = map(int, input().split())
    S: List[str] = []
    for a in range(n):
        S.append(input())
    
    # Sorting and output
    S.sort()
    print("".join(S))

# Execution
main()
```
