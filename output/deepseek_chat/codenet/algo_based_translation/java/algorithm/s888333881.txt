**Algorithm:**

1. **Input:**
   - Integer `n`
   - String `s` of length `n`

2. **Initialize:**
   - Boolean array `flaged` of size `n` (all false)
   - `pop1st` = count of '1's in `s`
   - `surp1` = 0 (mod pop1st+1)
   - `surp9` = 0 (mod pop1st-1, if pop1st>1)

3. **Calculate surp1:**
   - For i from 0 to n-1:
     - `surp1` = (surp1 * 2) % (pop1st+1)
     - If s[i]=='1': surp1 = (surp1 + 1) % (pop1st+1)

4. **Calculate surp9 (if pop1st>1):**
   - For i from 0 to n-1:
     - `surp9` = (surp9 * 2) % (pop1st-1)
     - If s[i]=='1': surp9 = (surp9 + 1) % (pop1st-1)

5. **Process each position p:**
   - For p from 0 to n-1:
     - If flaged[p] (s[p]=='1'):
       - If pop1st==1: output 0
       - Else:
         - `dw` = surp9
         - `dif` = pow10E97(2, n-p-1, pop1st-1)
         - `dw` = (dw - dif + pop1st-1) % (pop1st-1)
         - `ans` = 1
         - While dw != 0:
           - `count` = countFlaged(dw)
           - `dw` = dw % count
           - `ans`++
         - Output ans
     - Else:
       - `dw` = surp1
       - `dif` = pow10E97(2, n-p-1, pop1st+1)
       - `dw` = (dw + dif) % (pop1st+1)
       - `ans` = 1
       - While dw != 0:
         - `count` = countFlaged(dw)
         - `dw` = dw % count
         - `ans`++
       - Output ans

**Helper Functions:**

- `pow10E97(base, exponent, modulus)`: Modular exponentiation using binary exponentiation
- `countFlaged(number)`: Counts number of set bits in binary representation
- `getDigit2(number)`: Returns number of bits needed to represent number
- Various utility functions (abs, min, max, gcd, etc.)
