**Function Signature:**
- main(): void (implicit entry point)

**Variables:**
- D: int (number of problem sets)
- G: int (target score)
- PC: list[tuple[int, int]] (list of (problem_count, bonus_score) pairs)
- ans: int (minimum number of problems)
- i: int (bitmask iterator)
- score: int (current accumulated score)
- problem: int (current problem count)
- j: int (index variable)
- left: int (remaining score needed)
- tmp: int (temporary calculation)

**Algorithm:**
1. Read D and G from input
2. Read D lines of input, each containing two integers (p, c)
3. Initialize ans to a large value (10^9)
4. For each bitmask i from 0 to (2^D - 1):
   - Initialize score = 0, problem = 0
   - For each j from 0 to D-1:
     - If j-th bit of i is set:
       - Add (100*(j+1)*PC[j][0] + PC[j][1]) to score
       - Add PC[j][0] to problem
   - If score > G: skip to next iteration
   - Calculate left = G - score
   - For each j from 0 to D-1:
     - If j-th bit of i is set: skip to next j
     - If left > (100*(j+1)*PC[j][0] + PC[j][1]): do nothing
     - Else:
       - Calculate tmp = ceil(left / (100*(j+1)))
       - Update ans = min(ans, problem + min(tmp, PC[j][0]))
5. Print ans
