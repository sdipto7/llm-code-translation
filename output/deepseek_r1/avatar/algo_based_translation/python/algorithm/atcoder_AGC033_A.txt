**Structured Algorithm Specification**

**Function/Method Signatures:**
- *No explicit functions defined (script-based execution)*

**Variables:**
- `h: int` - Height of the grid
- `w: int` - Width of the grid
- `graph: 2D numpy.ndarray[float]` - Grid storing distances
- `x: int` - Column iteration variable
- `y: int` - Row iteration variable

**Input Operations:**
1. Read `h` and `w` from standard input via `input().split()`.
2. Read `h` lines of input, each containing `w` characters. Convert to 2D list:
   - `0.0` for `'#'`
   - `float('inf')` otherwise

**Data Processing:**
1. Convert the 2D list into a numpy array `graph`.

**Control Flow & Logic:**

1. **Left-to-Right Column Propagation:**
   - **Loop:** `for x in 0 to w-2` (inclusive)
   - **Action:**  
     `graph[:, x+1] = np.minimum(graph[:, x] + 1, graph[:, x+1])`

2. **Right-to-Left Column Propagation:**
   - **Loop:** `for x in w-1 downto 1` (inclusive)
   - **Action:**  
     `graph[:, x-1] = np.minimum(graph[:, x] + 1, graph[:, x-1])`

3. **Top-to-Bottom Row Propagation:**
   - **Loop:** `for y in 0 to h-2` (inclusive)
   - **Action:**  
     `graph[y+1, :] = np.minimum(graph[y, :] + 1, graph[y+1, :])`

4. **Bottom-to-Top Row Propagation:**
   - **Loop:** `for y in h-1 downto 1` (inclusive)
   - **Action:**  
     `graph[y-1, :] = np.minimum(graph[y, :] + 1, graph[y-1, :])`

**Output Operation:**
- Compute `np.max(graph)`, cast to `int`, and print the result.

**Edge Case Handling:**
- All `'#'` cells result in maximum distance `0`.
- Proper handling of grid boundaries via loop ranges.

**Dependencies:**
- `numpy` library for:
  - Array initialization (`np.array()`)
  - Element-wise minimum comparison (`np.minimum()`)
  - Maximum value computation (`np.max()`)
