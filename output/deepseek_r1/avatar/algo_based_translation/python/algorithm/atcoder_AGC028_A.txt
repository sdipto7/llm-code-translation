**Algorithm Specification**

**Function Signatures:**
- `gcd(a: int, b: int) -> int`

**Variables:**
- `N: int`
- `M: int`
- `S: str`
- `T: str`
- `list_S: List[str]`
- `list_T: List[str]`
- `Number_i: List[int]`
- `Number_iMN: List[float]`
- `Number_j: List[int]`
- `Kaburi_j: List[int]`
- `Kaburi_i: List[int]`
- `counter: int`
- `Flag: int`
- `Kaburi_Size: int`

**Steps:**

1. **Input Operations:**
    1. Read `N` and `M` from standard input as space-separated integers.
    2. Read `S` from standard input.
    3. Read `T` from standard input.

2. **Data Initialization:**
    1. Convert `S` to `list_S` (list of characters).
    2. Convert `T` to `list_T` (list of characters).
    3. Initialize `Number_i` as `[0, 1, ..., N-1]`.
    4. Initialize `Number_iMN` by computing `i*M/N` for each `i` in `Number_i`.
    5. Initialize `Number_j` as `[0, 1, ..., M-1]`.

3. **Overlap Detection:**
    1. Compute `Kaburi_j` as the intersection of `Number_iMN` (cast to integers where applicable) and `Number_j`.
    2. Convert `Kaburi_j` to a sorted list of integers.
    3. For each `j` in `Kaburi_j`, compute `i = j*N/M` (integer division), append to `Kaburi_i`.

4. **Character Comparison:**
    1. Initialize `counter = 0` and `Flag = 0`.
    2. Set `Kaburi_Size = len(Kaburi_i)`.
    3. While `counter < Kaburi_Size`:
        1. If `list_S[Kaburi_i[counter]] != list_T[Kaburi_j[counter]]`:
            1. Set `Flag = 1`.
            2. Break loop.
        2. Increment `counter` by 1.

5. **Output Decision:**
    1. If `Flag == 1`:
        1. Print `-1`.
    2. Else:
        1. Compute `gcd_val = gcd(N, M)`.
        2. Compute `lcm = (N * M) // gcd_val`.
        3. Print `lcm`.

**Control Structures:**
- Loop: `for i in Number_i` to build `Number_iMN`.
- Set intersection to compute `Kaburi_j`.
- Loop: `for j in Kaburi_j` to build `Kaburi_i`.
- While loop: `while counter < Kaburi_Size` for character comparison.
- Conditional break on mismatch detection.
- Final conditional (`Flag` check) for output decision.

**Edge Case Handling:**
- Empty `Kaburi_j` results in no comparisons, proceeding to LCM calculation.
- Division operations handle integer conversion via `int()` casting.
- GCD computation handles zero via Euclidean algorithm's inherent logic.

**External Dependencies:**
- Standard input handling.
- No external libraries required beyond basic type conversion and set operations.
