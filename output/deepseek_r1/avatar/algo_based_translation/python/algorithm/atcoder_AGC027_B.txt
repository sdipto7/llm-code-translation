**Structured Algorithm Specification**

**Function/Method Signatures:**
- `compute_min_total_cost() -> int`
  - **Parameters:** None (reads from standard input)
  - **Return Type:** Integer

**Variables:**
1. `N: int` (number of elements in list A)
2. `X: int` (input parameter)
3. `A: List[int]` (input list of length N)
4. `S: List[int]` (prefix sums of A, length N)
5. `ans: float` (minimum energy, initialized to positive infinity)
6. `E: int` (intermediate energy calculation for current k)
7. `sum_Sj: int` (sum of selected prefix sums for current k)
8. `start_j: int` (starting index for j in current iteration)
9. `j: int` (loop variable for index selection)
10. `total: int` (final computed result)

**Input/Output Operations:**
1. Read all input as integers via standard input.
2. Split input into tokens. First two tokens are N and X; remaining tokens form A.
3. Print `total` as the final result.

**External Dependencies:**
- `itertools.accumulate` for computing prefix sums of A.

**Control Flow and Logic:**

1. **Input Processing:**
   1.1. Read entire input and split into integer tokens.
   1.2. Assign first token to N, second to X, remaining tokens to A.

2. **Prefix Sum Calculation:**
   2.1. Compute S as cumulative sums of A using `accumulate(A)`.
   2.2. Convert S to a list.

3. **Minimum Energy Calculation:**
   3.1. Initialize ans = positive infinity.
   3.2. For each k in 1 to N (inclusive):
      3.2.1. Calculate start_j = N - 2 * k - 1.
      3.2.2. Initialize sum_Sj = 0.
      3.2.3. For j in range(start_j, -1, step=-k):
          - If j >= 0: sum_Sj += S[j]
      3.2.4. Compute E = k * X + 2 * sum_Sj.
      3.2.5. Update ans = min(ans, E).

4. **Final Result Computation:**
   4.1. Calculate total = ans + N * X + 5 * S[-1].
   4.2. Output total as integer.

**Edge Case Handling:**
- Implicit handling via range selection:
  - When N < 2k + 1 (`start_j` becomes negative), sum_Sj = 0 for that k.
- No explicit error checking for input validity (assumes correct input format).

**Loop Exit Criteria:**
- Outer loop exits after processing all k from 1 to N.
- Inner j loop exits when j < 0 (range ends before stop -1).
