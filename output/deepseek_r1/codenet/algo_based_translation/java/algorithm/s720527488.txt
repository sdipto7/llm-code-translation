Here is the algorithm extracted from the Java code:

1. **Input Reading**
   - Read integers `m` (number of manju) and `n` (number of boxes)
   - Read array `manju` of size `m`
   - Read arrays `boxlen` and `boxcost` of size `n`

2. **Sorting**
   - Sort `manju` array in ascending order (using a modified shuffle + Arrays.sort)

3. **Dynamic Programming Setup**
   - Initialize 2D array `dp` with dimensions `(m+1) x (n+1)`

4. **DP Table Population**
   - For `i` from `m-1` downto `0`:
     - For `j` from `n-1` downto `0`:
       - Calculate `len = min(i + boxlen[j], m)`
       - Compute `cnt` as sum of `manju[m-1-k]` for `k` from `i` to `len-1`
       - Update `dp[i][j]` with max of:
         - Taking current box: `dp[len][j+1] + cnt - boxcost[j]`
         - Skipping current box: `dp[i][j+1]`

5. **Output Result**
   - Print `dp[0][0]`

**Data Structures:**
- Integer arrays: `manju`, `boxlen`, `boxcost`
- 2D integer array `dp` for state transitions

**Control Flow:**
- Reverse-order nested loops (i descending, j descending)
- Conditional box capacity limit (`min(i + boxlen[j], m)`)
- Summation loop for manju values between indices
- Max selection between box usage options

**Key Operations:**
- Sorting manju values
- Cost-adjusted profit maximization through DP
- Reverse iteration for bottom-up DP approach

**Dependencies:**
- Custom input reader for fast I/O
- Arrays.sort for sorting
- Random shuffle during sorting initialization
